<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数组去重的方法</title>
    <link href="/2022/05/18/JavaScript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/18/JavaScript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="个人理解写"><a href="#个人理解写" class="headerlink" title="个人理解写"></a>个人理解写</h1><p>双循环</p><p>原数组排序后，邻近数组去重，push</p><p>使用indexOf （ES5）或者includes （ES6）</p><p>使用set</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> mOriginArray = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<br><br>mOriginArray.<span class="hljs-title function_">sort</span>()<br><br><br><span class="hljs-keyword">let</span> swapArray = []<br><br>mOriginArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(swapArray.<span class="hljs-property">length</span> != <span class="hljs-number">0</span> &amp;&amp; swapArray[index - <span class="hljs-number">1</span>] === item) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    swapArray.<span class="hljs-title function_">push</span>(item)<span class="hljs-comment">//切记不能用swapArray[index] = item</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// mOriginArray.forEach(item =&gt; &#123;</span><br><span class="hljs-comment">//   if(!swapArray.includes(item)) &#123;</span><br><span class="hljs-comment">//       swapArray.push(item)</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-comment">// let mSet = new Set(mOriginArray)</span><br><br><span class="hljs-comment">// console.log(Array.from(mSet))</span><br><span class="hljs-comment">// console.log([...mSet])</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(swapArray)<br></code></pre></td></tr></table></figure><h1 id="7种方法实现数组去重"><a href="#7种方法实现数组去重" class="headerlink" title="7种方法实现数组去重"></a>7种方法实现数组去重</h1><p>2018年05月05日 16:01 ·  阅读 50540</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去重是开发中经常会碰到的一个热点问题，不过目前项目中碰到的情况都是后台接口使用SQL去重，简单高效，基本不会让前端处理去重。</p><p>那么前端处理去重会出现什么情况呢？假如每页显示10条不同的数据，如果数据重复比较严重，那么要显示10条数据，可能需要发送多个http请求才能够筛选出10条不同的数据，而如果在后台就去重了的话，只需一次http请求就能够获取到10条不同的数据。</p><p>当然，这并不是说前端去重就没有必要了，依然需要会熟练使用。本文主要介绍几种常见的数组去重的方法。</p><h2 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h2><h3 id="双循环去重"><a href="#双循环去重" class="headerlink" title="双循环去重"></a>双循环去重</h3><p>双重for（或while）循环是比较笨拙的方法，它实现的原理很简单：先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组；因为它的时间复杂度是O(n^2)，如果数组长度很大，那么将会非常耗费内存</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs maxima">function <span class="hljs-built_in">unique</span>(arr) &#123;<br>    <span class="hljs-keyword">if</span> (!Array.isArray(arr)) &#123;<br>        console.<span class="hljs-built_in">log</span>(&#x27;type <span class="hljs-built_in">error</span>!&#x27;)<br>        <span class="hljs-built_in">return</span><br>    &#125;<br>    <span class="hljs-built_in">let</span> res = [arr[<span class="hljs-number">0</span>]]<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>        <span class="hljs-built_in">let</span> flag = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> j = <span class="hljs-number">0</span>; j &lt; res.<span class="hljs-built_in">length</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] === res[j]) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-built_in">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            res.<span class="hljs-built_in">push</span>(arr[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">return</span> res<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="indexOf方法去重1"><a href="#indexOf方法去重1" class="headerlink" title="indexOf方法去重1"></a>indexOf方法去重1</h3><p>数组的indexOf()方法可返回某个指定的元素在数组中首次出现的位置。该方法首先定义一个空数组res，然后调用indexOf方法对原来的数组进行遍历判断，如果元素不在res中，则将其push进res中，最后将res返回即可获得去重的数组</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    let res = []<br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">indexOf</span>(arr[i]) === <span class="hljs-number">-1</span>) &#123;<br>            res.<span class="hljs-built_in">push</span>(arr[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="indexOf方法去重2"><a href="#indexOf方法去重2" class="headerlink" title="indexOf方法去重2"></a>indexOf方法去重2</h3><p>利用indexOf检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.<span class="hljs-built_in">filter</span>.call(arr, <span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr.<span class="hljs-built_in">indexOf</span>(item) === index;<br>    &#125;);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="相邻元素去重"><a href="#相邻元素去重" class="headerlink" title="相邻元素去重"></a>相邻元素去重</h3><p>这种方法首先调用了数组的排序方法sort()，然后根据排序后的结果进行遍历及相邻元素比对，如果相等则跳过改元素，直到遍历结束</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    arr = arr.<span class="hljs-built_in">sort</span>()<br>    let res = []<br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] !== arr[i<span class="hljs-number">-1</span>]) &#123;<br>            res.<span class="hljs-built_in">push</span>(arr[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="利用对象属性去重"><a href="#利用对象属性去重" class="headerlink" title="利用对象属性去重"></a>利用对象属性去重</h3><p>创建空对象，遍历数组，将数组中的值设为对象的属性，并给该属性赋初始值1，每出现一次，对应的属性值增加1，这样，属性值对应的就是该元素出现的次数了</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    let res = [],<br>        obj = &#123;&#125;<br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!obj[arr[i]]) &#123;<br>            res.<span class="hljs-built_in">push</span>(arr[i])<br>            obj[arr[i]] = <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            obj[arr[i]]++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="set与解构赋值去重"><a href="#set与解构赋值去重" class="headerlink" title="set与解构赋值去重"></a>set与解构赋值去重</h3><p>ES6中新增了数据类型set，set的一个最大的特点就是数据不重复。Set函数可以接受一个数组（或类数组对象）作为参数来初始化，利用该特性也能做到给数组去重</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(arr) &#123;<br>    if (!Array.<span class="hljs-keyword">is</span><span class="hljs-keyword">Array</span>(arr)) &#123;<br>        console.log(<span class="hljs-symbol">&#x27;type</span> error!&#x27;)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> Set(arr)]<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="Array-from与set去重"><a href="#Array-from与set去重" class="headerlink" title="Array.from与set去重"></a>Array.from与set去重</h3><p>Array.from方法可以将Set结构转换为数组结果，而我们知道set结果是不重复的数据集，因此能够达到去重的目的</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">unique</span>(arr) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">Array</span>.isArray(arr)) &#123;<br>        console.log(<span class="hljs-string">&#x27;type error!&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">from</span>(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Set</span>(arr))<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数组去重是开发中经常会碰到的一个热点问题。我们可以根据不同的应用场景来选择不同的实现方式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的Diff算法</title>
    <link href="/2022/04/02/Vue/diff/Diff/"/>
    <url>/2022/04/02/Vue/diff/Diff/</url>
    
    <content type="html"><![CDATA[<h1 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h1><aside>🆕 **Diff算法是一种对比算法**。对比两者是`旧虚拟DOM和新虚拟DOM`，对比出是哪个`虚拟节点`更改了，找出这个`虚拟节点`，并只更新这个虚拟节点所对应的`真实节点`，而不用更新其他数据没发生改变的节点，实现`精准`地更新真实DOM，进而`提高效率`。</aside><p>新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:<code>深度优先算法</code>。 时间复杂度:<code>O(n)</code></p><h2 id="如何触发"><a href="#如何触发" class="headerlink" title="如何触发"></a>如何触发</h2><p>当数据改变时，会触发<code>setter</code>，并且通过<code>Dep.notify</code>去通知所有<code>订阅者Watcher</code>，订阅者们就会调用<code>patch方法</code>，给真实DOM打补丁，更新相应的视图。</p><p> <img src="/images/diff/diff7.png" alt="Vue触发Diff的流程"></p><h2 id="核心方法："><a href="#核心方法：" class="headerlink" title="核心方法："></a>核心方法：</h2><h3 id="1-patch方法"><a href="#1-patch方法" class="headerlink" title="1. patch方法"></a>1. patch方法</h3><figure class="highlight jsx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVnode, newVnode</span>) &#123;<br>  <span class="hljs-comment">// 比较是否为一个类型的节点</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldVnode, newVnode)) &#123; **<span class="hljs-comment">// 重点**</span><br>    <span class="hljs-comment">// 是：继续进行深层比较</span><br>    <span class="hljs-title function_">patchVnode</span>(oldVnode, newVnode) **<span class="hljs-comment">// 重点**</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 否</span><br>    <span class="hljs-keyword">const</span> oldEl = oldVnode.<span class="hljs-property">el</span> <span class="hljs-comment">// 旧虚拟节点的真实DOM节点</span><br>    <span class="hljs-keyword">const</span> parentEle = api.<span class="hljs-title function_">parentNode</span>(oldEl) <span class="hljs-comment">// 获取父节点</span><br>    <span class="hljs-title function_">createEle</span>(newVnode) <span class="hljs-comment">// 创建新虚拟节点对应的真实DOM节点</span><br>    <span class="hljs-keyword">if</span> (parentEle !== <span class="hljs-literal">null</span>) &#123;<br>      api.<span class="hljs-title function_">insertBefore</span>(parentEle, vnode.<span class="hljs-property">el</span>, api.<span class="hljs-title function_">nextSibling</span>(oEl)) <span class="hljs-comment">// 将新元素添加进父元素</span><br>      api.<span class="hljs-title function_">removeChild</span>(parentEle, oldVnode.<span class="hljs-property">el</span>)  <span class="hljs-comment">// 移除以前的旧元素节点</span><br>      <span class="hljs-comment">// 设置null，释放内存</span><br>      oldVnode = <span class="hljs-literal">null</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newVnode<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签<code>(同一类型的标准，下面会讲)</code>：</p><ul><li>是：继续执行<code>patchVnode方法</code>进行深层比对</li><li>否：没必要比对了，直接整个节点替换成<code>新虚拟节点</code></li></ul><h3 id="2-sameVnode方法"><a href="#2-sameVnode方法" class="headerlink" title="2. sameVnode方法"></a>2. <strong>sameVnode方法</strong></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sameVnode</span>(<span class="hljs-params">oldVnode, newVnode</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    oldVnode.<span class="hljs-property">key</span> === newVnode.<span class="hljs-property">key</span> &amp;&amp; <span class="hljs-comment">// key值是否一样</span><br>    oldVnode.<span class="hljs-property">tagName</span> === newVnode.<span class="hljs-property">tagName</span> &amp;&amp; <span class="hljs-comment">// 标签名是否一样</span><br>    oldVnode.<span class="hljs-property">isComment</span> === newVnode.<span class="hljs-property">isComment</span> &amp;&amp; <span class="hljs-comment">// 是否都为注释节点</span><br>    <span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">data</span>) === <span class="hljs-title function_">isDef</span>(newVnode.<span class="hljs-property">data</span>) &amp;&amp; <span class="hljs-comment">// 是否都定义了data</span><br>    <span class="hljs-title function_">sameInputType</span>(oldVnode, newVnode) <span class="hljs-comment">// 当标签为input时，type必须是否相同</span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>patch关键的一步就是<code>sameVnode方法判断是否为同一类型节点</code></p><h3 id="3-patchVnode方法"><a href="#3-patchVnode方法" class="headerlink" title="3. patchVnode方法"></a>3. <strong>patchVnode方法</strong></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchVnode</span>(<span class="hljs-params">oldVnode, newVnode</span>) &#123;<br>  <span class="hljs-keyword">const</span> el = newVnode.<span class="hljs-property">el</span> = oldVnode.<span class="hljs-property">el</span> <span class="hljs-comment">// 获取真实DOM对象</span><br>  <span class="hljs-comment">// 获取新旧虚拟节点的子节点数组</span><br>  <span class="hljs-keyword">const</span> oldCh = oldVnode.<span class="hljs-property">children</span>, newCh = newVnode.<span class="hljs-property">children</span><br>  <span class="hljs-comment">// 如果新旧虚拟节点是同一个对象，则终止</span><br>  <span class="hljs-keyword">if</span> (oldVnode === newVnode) <span class="hljs-keyword">return</span><br>  <span class="hljs-comment">// 如果新旧虚拟节点是**文本节点**，且文本不一样</span><br>  <span class="hljs-keyword">if</span> (oldVnode.<span class="hljs-property">text</span> !== <span class="hljs-literal">null</span> &amp;&amp; newVnode.<span class="hljs-property">text</span> !== <span class="hljs-literal">null</span> &amp;&amp; oldVnode.<span class="hljs-property">text</span> !== newVnode.<span class="hljs-property">text</span>) &#123;<br>    <span class="hljs-comment">// 则直接将真实DOM中文本更新为新虚拟节点的文本</span><br>    api.<span class="hljs-title function_">setTextContent</span>(el, newVnode.<span class="hljs-property">text</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 否则</span><br><br>    <span class="hljs-keyword">if</span> (oldCh &amp;&amp; newCh &amp;&amp; oldCh !== newCh) &#123;<br>      <span class="hljs-comment">// 新旧虚拟节点都有子节点，且子节点不一样</span><br><br>      <span class="hljs-comment">// 对比子节点，并更新</span><br>      <span class="hljs-title function_">updateChildren</span>(el, oldCh, newCh) **<span class="hljs-comment">// 重点**</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newCh) &#123;<br>      <span class="hljs-comment">// 新虚拟节点有子节点，旧虚拟节点没有</span><br><br>      <span class="hljs-comment">// 创建新虚拟节点的子节点，并更新到真实DOM上去</span><br>      <span class="hljs-title function_">createEle</span>(newVnode)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldCh) &#123;<br>      <span class="hljs-comment">// 旧虚拟节点有子节点，新虚拟节点没有</span><br><br>      <span class="hljs-comment">//直接删除真实DOM里对应的子节点</span><br>      api.<span class="hljs-title function_">removeChild</span>(el)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数做了以下事情：</p><ul><li>找到对应的<code>真实DOM</code>，称为<code>el</code></li><li>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是，那么直接<code>return</code></li><li>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点。</li><li>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除<code>el</code>的子节点</li><li>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点真实化之后添加到<code>el</code></li><li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，这一步很重要</li></ul><h3 id="4-updateChildren方法"><a href="#4-updateChildren方法" class="headerlink" title="4. updateChildren方法"></a>4. <strong>updateChildren方法</strong></h3><p>这是<code>patchVnode</code>里最重要的一个方法，新旧虚拟节点的子节点对比，就是发生在<code>updateChildren方法</code>中</p><p>是怎么样一个对比方法呢？就是<code>首尾指针法</code>，新的子节点集合和旧的子节点集合，各有首尾两个指针</p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>修改数据后<br><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>e<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么新旧两个子节点集合以及其首尾指针为：</p><p><img src="/images/diff/diff.png" alt="Untitled"></p><p>然后会进行互相进行比较，总共有五种比较情况：</p><ul><li>1、<code>oldS 和 newS</code> 使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newS)</code></li><li>2、<code>oldS 和 newE</code> 使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newE)</code></li><li>3、<code>oldE 和 newS</code> 使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newS)</code></li><li>4、<code>oldE 和 newE</code> 使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newE)</code></li><li>5、如果以上逻辑都匹配不到，再把所有旧子节点的 <code>key</code> 做一个映射到旧节点下标的 <code>key -&gt; index</code> 表，然后用新 <code>vnode</code> 的 <code>key</code> 去找出在旧节点中可以复用的位置。</li></ul><p><img src="/images/diff/diff1.png" alt="Untitled"></p><h2 id="分析过程："><a href="#分析过程：" class="headerlink" title="分析过程："></a>分析过程：</h2><p><img src="/images/diff/diff2.png" alt="Untitled"></p><ul><li>第一步</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">oldS = a, oldE = c<br>newS = b, newE = a<br></code></pre></td></tr></table></figure><p>比较结果：<code>oldS 和 newE</code>相等，需要把<code>节点a</code>移动到<code>newE</code>所对应的位置，也就是末尾，同时<code>oldS++</code>，<code>newE--</code></p><p><img src="/images/diff/diff3.png" alt="Untitled"></p><ul><li>第二步</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">oldS = b, oldE = c<br>newS = b, newE = e<br></code></pre></td></tr></table></figure><p>比较结果：<code>oldS 和 newS</code>相等，需要把<code>节点b</code>移动到<code>newS</code>所对应的位置，同时<code>oldS++</code>,<code>newS++</code></p><p><img src="/images/diff/diff4.png" alt="Untitled"></p><ul><li>第三步</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">oldS = c, oldE = c<br>newS = c, newE = e<br></code></pre></td></tr></table></figure><p>比较结果：<code>oldS、oldE 和 newS</code>相等，需要把<code>节点c</code>移动到<code>newS</code>所对应的位置，同时<code>oldS++</code>,<code>newS++</code></p><p><img src="/images/diff/diff5.png" alt="Untitled"></p><ul><li>第四步</li></ul><p><code>oldS &gt; oldE</code>，则<code>oldCh</code>先遍历完成了，而<code>newCh</code>还没遍历完，说明<code>newCh比oldCh多</code>，所以需要将多出来的节点，插入到真实DOM上对应的位置上</p><p><img src="/images/diff/diff6.png" alt="Untitled"></p></blockquote><p><code>updateChildren</code>的核心原理代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span>(<span class="hljs-params">parentElm, oldCh, newCh</span>) &#123;<br>  <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>, newStartIdx = <span class="hljs-number">0</span> <span class="hljs-comment">//旧节点数组与新节点数组的下标</span><br>  <span class="hljs-keyword">let</span> oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>] <span class="hljs-comment">//旧节点数组第一个子节点</span><br>  <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx]<br>  <span class="hljs-keyword">let</span> newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>]<br>  <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="hljs-comment">// 准备工作</span><br>  <span class="hljs-keyword">let</span> oldKeyToIdx<br>  <span class="hljs-keyword">let</span> idxInOld<br>  <span class="hljs-keyword">let</span> elmToMove<br>  <span class="hljs-keyword">let</span> before<br>  <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>    <span class="hljs-keyword">if</span> (oldStartVnode == <span class="hljs-literal">null</span>) &#123;<br>      oldStartVnode = oldCh[++oldStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldEndVnode == <span class="hljs-literal">null</span>) &#123;<br>      oldEndVnode = oldCh[--oldEndIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartVnode == <span class="hljs-literal">null</span>) &#123;<br>      newStartVnode = newCh[++newStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newEndVnode == <span class="hljs-literal">null</span>) &#123;<br>      newEndVnode = newCh[--newEndIdx] <span class="hljs-comment">//先判断节点是否为null</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;<br>      <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newStartVnode)<br>      oldStartVnode = oldCh[++oldStartIdx]<br>      newStartVnode = newCh[++newStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;<br>      <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newEndVnode)<br>      oldEndVnode = oldCh[--oldEndIdx]<br>      newEndVnode = newCh[--newEndIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123;<br>      <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newEndVnode)<br>      api.<span class="hljs-title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="hljs-property">el</span>, api.<span class="hljs-title function_">nextSibling</span>(oldEndVnode.<span class="hljs-property">el</span>))<br>      oldStartVnode = oldCh[++oldStartIdx]<br>      newEndVnode = newCh[--newEndIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123;<br>      <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newStartVnode)<br>      api.<span class="hljs-title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="hljs-property">el</span>, oldStartVnode.<span class="hljs-property">el</span>)<br>      oldEndVnode = oldCh[--oldEndIdx]<br>      newStartVnode = newCh[++newStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 使用key时的比较</span><br>      <span class="hljs-keyword">if</span> (oldKeyToIdx === <span class="hljs-literal">undefined</span>) &#123;<br>        oldKeyToIdx = <span class="hljs-title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx) <span class="hljs-comment">// 有key生成index表</span><br>      &#125;<br>      idxInOld = oldKeyToIdx[newStartVnode.<span class="hljs-property">key</span>]<br>      <span class="hljs-keyword">if</span> (!idxInOld) &#123;<br>        api.<span class="hljs-title function_">insertBefore</span>(parentElm, <span class="hljs-title function_">createEle</span>(newStartVnode).<span class="hljs-property">el</span>, oldStartVnode.<span class="hljs-property">el</span>)<br>        newStartVnode = newCh[++newStartIdx]<br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>        elmToMove = oldCh[idxInOld]<br>        <span class="hljs-keyword">if</span> (elmToMove.<span class="hljs-property">sel</span> !== newStartVnode.<span class="hljs-property">sel</span>) &#123;<br>          api.<span class="hljs-title function_">insertBefore</span>(parentElm, <span class="hljs-title function_">createEle</span>(newStartVnode).<span class="hljs-property">el</span>, oldStartVnode.<span class="hljs-property">el</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">patchVnode</span>(elmToMove, newStartVnode)<br>          oldCh[idxInOld] = <span class="hljs-literal">null</span><br>          api.<span class="hljs-title function_">insertBefore</span>(parentElm, elmToMove.<span class="hljs-property">el</span>, oldStartVnode.<span class="hljs-property">el</span>)<br>        &#125;<br>        newStartVnode = newCh[++newStartIdx]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;<br>    before = newCh[newEndIdx + <span class="hljs-number">1</span>] == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : newCh[newEndIdx + <span class="hljs-number">1</span>].<span class="hljs-property">el</span><br>    <span class="hljs-title function_">addVnodes</span>(parentElm, before, newCh, newStartIdx, newEndIdx)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;<br>    <span class="hljs-title function_">removeVnodes</span>(parentElm, oldCh, oldStartIdx, oldEndIdx)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="https://juejin.cn/post/6994959998283907102">15张图，20分钟吃透Diff算法核心原理，我说的！！！ - 掘金</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About</title>
    <link href="/2022/03/30/about/index/"/>
    <url>/2022/03/30/about/index/</url>
    
    <content type="html"><![CDATA[<h1 id="待完善"><a href="#待完善" class="headerlink" title="待完善"></a>待完善</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/29/hello-world/"/>
    <url>/2022/03/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
