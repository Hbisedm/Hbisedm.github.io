<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/04/03/diff/Diff%E7%AE%97%E6%B3%95%2070a7b/"/>
    <url>/2022/04/03/diff/Diff%E7%AE%97%E6%B3%95%2070a7b/</url>
    
    <content type="html"><![CDATA[<h1 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h1><p>Tags: 算法</p><aside>🆕 **Diff算法是一种对比算法**。对比两者是`旧虚拟DOM和新虚拟DOM`，对比出是哪个`虚拟节点`更改了，找出这个`虚拟节点`，并只更新这个虚拟节点所对应的`真实节点`，而不用更新其他数据没发生改变的节点，实现`精准`地更新真实DOM，进而`提高效率`。</aside><p>新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:<code>深度优先算法</code>。 时间复杂度:<code>O(n)</code></p><h2 id="如何触发"><a href="#如何触发" class="headerlink" title="如何触发"></a>如何触发</h2><p>当数据改变时，会触发<code>setter</code>，并且通过<code>Dep.notify</code>去通知所有<code>订阅者Watcher</code>，订阅者们就会调用<code>patch方法</code>，给真实DOM打补丁，更新相应的视图。</p><p><a href="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1db54647698e4c76b6fc38a02067ad72~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp">https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1db54647698e4c76b6fc38a02067ad72~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp</a></p><h2 id="核心方法："><a href="#核心方法：" class="headerlink" title="核心方法："></a>核心方法：</h2><h3 id="1-patch方法"><a href="#1-patch方法" class="headerlink" title="1. patch方法"></a>1. patch方法</h3><figure class="highlight jsx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVnode, newVnode</span>) &#123;<br>  <span class="hljs-comment">// 比较是否为一个类型的节点</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldVnode, newVnode)) &#123; **<span class="hljs-comment">// 重点**</span><br>    <span class="hljs-comment">// 是：继续进行深层比较</span><br>    <span class="hljs-title function_">patchVnode</span>(oldVnode, newVnode) **<span class="hljs-comment">// 重点**</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 否</span><br>    <span class="hljs-keyword">const</span> oldEl = oldVnode.<span class="hljs-property">el</span> <span class="hljs-comment">// 旧虚拟节点的真实DOM节点</span><br>    <span class="hljs-keyword">const</span> parentEle = api.<span class="hljs-title function_">parentNode</span>(oldEl) <span class="hljs-comment">// 获取父节点</span><br>    <span class="hljs-title function_">createEle</span>(newVnode) <span class="hljs-comment">// 创建新虚拟节点对应的真实DOM节点</span><br>    <span class="hljs-keyword">if</span> (parentEle !== <span class="hljs-literal">null</span>) &#123;<br>      api.<span class="hljs-title function_">insertBefore</span>(parentEle, vnode.<span class="hljs-property">el</span>, api.<span class="hljs-title function_">nextSibling</span>(oEl)) <span class="hljs-comment">// 将新元素添加进父元素</span><br>      api.<span class="hljs-title function_">removeChild</span>(parentEle, oldVnode.<span class="hljs-property">el</span>)  <span class="hljs-comment">// 移除以前的旧元素节点</span><br>      <span class="hljs-comment">// 设置null，释放内存</span><br>      oldVnode = <span class="hljs-literal">null</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newVnode<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签<code>(同一类型的标准，下面会讲)</code>：</p><ul><li>是：继续执行<code>patchVnode方法</code>进行深层比对</li><li>否：没必要比对了，直接整个节点替换成<code>新虚拟节点</code></li></ul><h3 id="2-sameVnode方法"><a href="#2-sameVnode方法" class="headerlink" title="2. sameVnode方法"></a>2. <strong>sameVnode方法</strong></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sameVnode</span>(<span class="hljs-params">oldVnode, newVnode</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    oldVnode.<span class="hljs-property">key</span> === newVnode.<span class="hljs-property">key</span> &amp;&amp; <span class="hljs-comment">// key值是否一样</span><br>    oldVnode.<span class="hljs-property">tagName</span> === newVnode.<span class="hljs-property">tagName</span> &amp;&amp; <span class="hljs-comment">// 标签名是否一样</span><br>    oldVnode.<span class="hljs-property">isComment</span> === newVnode.<span class="hljs-property">isComment</span> &amp;&amp; <span class="hljs-comment">// 是否都为注释节点</span><br>    <span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">data</span>) === <span class="hljs-title function_">isDef</span>(newVnode.<span class="hljs-property">data</span>) &amp;&amp; <span class="hljs-comment">// 是否都定义了data</span><br>    <span class="hljs-title function_">sameInputType</span>(oldVnode, newVnode) <span class="hljs-comment">// 当标签为input时，type必须是否相同</span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>patch关键的一步就是<code>sameVnode方法判断是否为同一类型节点</code></p><h3 id="3-patchVnode方法"><a href="#3-patchVnode方法" class="headerlink" title="3. patchVnode方法"></a>3. <strong>patchVnode方法</strong></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchVnode</span>(<span class="hljs-params">oldVnode, newVnode</span>) &#123;<br>  <span class="hljs-keyword">const</span> el = newVnode.<span class="hljs-property">el</span> = oldVnode.<span class="hljs-property">el</span> <span class="hljs-comment">// 获取真实DOM对象</span><br>  <span class="hljs-comment">// 获取新旧虚拟节点的子节点数组</span><br>  <span class="hljs-keyword">const</span> oldCh = oldVnode.<span class="hljs-property">children</span>, newCh = newVnode.<span class="hljs-property">children</span><br>  <span class="hljs-comment">// 如果新旧虚拟节点是同一个对象，则终止</span><br>  <span class="hljs-keyword">if</span> (oldVnode === newVnode) <span class="hljs-keyword">return</span><br>  <span class="hljs-comment">// 如果新旧虚拟节点是**文本节点**，且文本不一样</span><br>  <span class="hljs-keyword">if</span> (oldVnode.<span class="hljs-property">text</span> !== <span class="hljs-literal">null</span> &amp;&amp; newVnode.<span class="hljs-property">text</span> !== <span class="hljs-literal">null</span> &amp;&amp; oldVnode.<span class="hljs-property">text</span> !== newVnode.<span class="hljs-property">text</span>) &#123;<br>    <span class="hljs-comment">// 则直接将真实DOM中文本更新为新虚拟节点的文本</span><br>    api.<span class="hljs-title function_">setTextContent</span>(el, newVnode.<span class="hljs-property">text</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 否则</span><br><br>    <span class="hljs-keyword">if</span> (oldCh &amp;&amp; newCh &amp;&amp; oldCh !== newCh) &#123;<br>      <span class="hljs-comment">// 新旧虚拟节点都有子节点，且子节点不一样</span><br><br>      <span class="hljs-comment">// 对比子节点，并更新</span><br>      <span class="hljs-title function_">updateChildren</span>(el, oldCh, newCh) **<span class="hljs-comment">// 重点**</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newCh) &#123;<br>      <span class="hljs-comment">// 新虚拟节点有子节点，旧虚拟节点没有</span><br><br>      <span class="hljs-comment">// 创建新虚拟节点的子节点，并更新到真实DOM上去</span><br>      <span class="hljs-title function_">createEle</span>(newVnode)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldCh) &#123;<br>      <span class="hljs-comment">// 旧虚拟节点有子节点，新虚拟节点没有</span><br><br>      <span class="hljs-comment">//直接删除真实DOM里对应的子节点</span><br>      api.<span class="hljs-title function_">removeChild</span>(el)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数做了以下事情：</p><ul><li>找到对应的<code>真实DOM</code>，称为<code>el</code></li><li>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是，那么直接<code>return</code></li><li>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点。</li><li>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除<code>el</code>的子节点</li><li>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点真实化之后添加到<code>el</code></li><li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，这一步很重要</li></ul><h3 id="4-updateChildren方法"><a href="#4-updateChildren方法" class="headerlink" title="4. updateChildren方法"></a>4. <strong>updateChildren方法</strong></h3><p>这是<code>patchVnode</code>里最重要的一个方法，新旧虚拟节点的子节点对比，就是发生在<code>updateChildren方法</code>中</p><p>是怎么样一个对比方法呢？就是<code>首尾指针法</code>，新的子节点集合和旧的子节点集合，各有首尾两个指针</p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>修改数据后<br><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>e<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么新旧两个子节点集合以及其首尾指针为：</p><p><img src="/assets/Untitled.png" alt="Untitled"></p><p>然后会进行互相进行比较，总共有五种比较情况：</p><ul><li>1、<code>oldS 和 newS</code> 使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newS)</code></li><li>2、<code>oldS 和 newE</code> 使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newE)</code></li><li>3、<code>oldE 和 newS</code> 使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newS)</code></li><li>4、<code>oldE 和 newE</code> 使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newE)</code></li><li>5、如果以上逻辑都匹配不到，再把所有旧子节点的 <code>key</code> 做一个映射到旧节点下标的 <code>key -&gt; index</code> 表，然后用新 <code>vnode</code> 的 <code>key</code> 去找出在旧节点中可以复用的位置。</li></ul><p><img src="/assets/Untitled%201.png" alt="Untitled"></p><h2 id="分析过程："><a href="#分析过程：" class="headerlink" title="分析过程："></a>分析过程：</h2><p><img src="/assets/Untitled%202.png" alt="Untitled"></p><ul><li>第一步</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">oldS = a, oldE = c<br>newS = b, newE = a<br></code></pre></td></tr></table></figure><p>比较结果：<code>oldS 和 newE</code>相等，需要把<code>节点a</code>移动到<code>newE</code>所对应的位置，也就是末尾，同时<code>oldS++</code>，<code>newE--</code></p><p><img src="/assets/Untitled%203.png" alt="Untitled"></p><ul><li>第二步</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">oldS = b, oldE = c<br>newS = b, newE = e<br></code></pre></td></tr></table></figure><p>比较结果：<code>oldS 和 newS</code>相等，需要把<code>节点b</code>移动到<code>newS</code>所对应的位置，同时<code>oldS++</code>,<code>newS++</code></p><p><img src="/assets/Untitled%204.png" alt="Untitled"></p><ul><li>第三步</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">oldS = c, oldE = c<br>newS = c, newE = e<br></code></pre></td></tr></table></figure><p>比较结果：<code>oldS、oldE 和 newS</code>相等，需要把<code>节点c</code>移动到<code>newS</code>所对应的位置，同时<code>oldS++</code>,<code>newS++</code></p><p><img src="/assets/Untitled%205.png" alt="Untitled"></p><ul><li>第四步</li></ul><p><code>oldS &gt; oldE</code>，则<code>oldCh</code>先遍历完成了，而<code>newCh</code>还没遍历完，说明<code>newCh比oldCh多</code>，所以需要将多出来的节点，插入到真实DOM上对应的位置上</p><p><img src="/assets/Untitled%206.png" alt="Untitled"></p></blockquote><p><code>updateChildren</code>的核心原理代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span>(<span class="hljs-params">parentElm, oldCh, newCh</span>) &#123;<br>  <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>, newStartIdx = <span class="hljs-number">0</span> <span class="hljs-comment">//旧节点数组与新节点数组的下标</span><br>  <span class="hljs-keyword">let</span> oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>] <span class="hljs-comment">//旧节点数组第一个子节点</span><br>  <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx]<br>  <span class="hljs-keyword">let</span> newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>]<br>  <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="hljs-comment">// 准备工作</span><br>  <span class="hljs-keyword">let</span> oldKeyToIdx<br>  <span class="hljs-keyword">let</span> idxInOld<br>  <span class="hljs-keyword">let</span> elmToMove<br>  <span class="hljs-keyword">let</span> before<br>  <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>    <span class="hljs-keyword">if</span> (oldStartVnode == <span class="hljs-literal">null</span>) &#123;<br>      oldStartVnode = oldCh[++oldStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldEndVnode == <span class="hljs-literal">null</span>) &#123;<br>      oldEndVnode = oldCh[--oldEndIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartVnode == <span class="hljs-literal">null</span>) &#123;<br>      newStartVnode = newCh[++newStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newEndVnode == <span class="hljs-literal">null</span>) &#123;<br>      newEndVnode = newCh[--newEndIdx] <span class="hljs-comment">//先判断节点是否为null</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;<br>      <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newStartVnode)<br>      oldStartVnode = oldCh[++oldStartIdx]<br>      newStartVnode = newCh[++newStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;<br>      <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newEndVnode)<br>      oldEndVnode = oldCh[--oldEndIdx]<br>      newEndVnode = newCh[--newEndIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123;<br>      <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newEndVnode)<br>      api.<span class="hljs-title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="hljs-property">el</span>, api.<span class="hljs-title function_">nextSibling</span>(oldEndVnode.<span class="hljs-property">el</span>))<br>      oldStartVnode = oldCh[++oldStartIdx]<br>      newEndVnode = newCh[--newEndIdx]<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123;<br>      <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newStartVnode)<br>      api.<span class="hljs-title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="hljs-property">el</span>, oldStartVnode.<span class="hljs-property">el</span>)<br>      oldEndVnode = oldCh[--oldEndIdx]<br>      newStartVnode = newCh[++newStartIdx]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 使用key时的比较</span><br>      <span class="hljs-keyword">if</span> (oldKeyToIdx === <span class="hljs-literal">undefined</span>) &#123;<br>        oldKeyToIdx = <span class="hljs-title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx) <span class="hljs-comment">// 有key生成index表</span><br>      &#125;<br>      idxInOld = oldKeyToIdx[newStartVnode.<span class="hljs-property">key</span>]<br>      <span class="hljs-keyword">if</span> (!idxInOld) &#123;<br>        api.<span class="hljs-title function_">insertBefore</span>(parentElm, <span class="hljs-title function_">createEle</span>(newStartVnode).<span class="hljs-property">el</span>, oldStartVnode.<span class="hljs-property">el</span>)<br>        newStartVnode = newCh[++newStartIdx]<br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>        elmToMove = oldCh[idxInOld]<br>        <span class="hljs-keyword">if</span> (elmToMove.<span class="hljs-property">sel</span> !== newStartVnode.<span class="hljs-property">sel</span>) &#123;<br>          api.<span class="hljs-title function_">insertBefore</span>(parentElm, <span class="hljs-title function_">createEle</span>(newStartVnode).<span class="hljs-property">el</span>, oldStartVnode.<span class="hljs-property">el</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">patchVnode</span>(elmToMove, newStartVnode)<br>          oldCh[idxInOld] = <span class="hljs-literal">null</span><br>          api.<span class="hljs-title function_">insertBefore</span>(parentElm, elmToMove.<span class="hljs-property">el</span>, oldStartVnode.<span class="hljs-property">el</span>)<br>        &#125;<br>        newStartVnode = newCh[++newStartIdx]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;<br>    before = newCh[newEndIdx + <span class="hljs-number">1</span>] == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : newCh[newEndIdx + <span class="hljs-number">1</span>].<span class="hljs-property">el</span><br>    <span class="hljs-title function_">addVnodes</span>(parentElm, before, newCh, newStartIdx, newEndIdx)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;<br>    <span class="hljs-title function_">removeVnodes</span>(parentElm, oldCh, oldStartIdx, oldEndIdx)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="https://juejin.cn/post/6994959998283907102">15张图，20分钟吃透Diff算法核心原理，我说的！！！ - 掘金</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>demo1/demo2</title>
    <link href="/2022/03/30/demo1-demo2-1/"/>
    <url>/2022/03/30/demo1-demo2-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Diff算法</title>
    <link href="/2022/03/30/Vue/Diff/"/>
    <url>/2022/03/30/Vue/Diff/</url>
    
    <content type="html"><![CDATA[<h1 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>demo1/demo2</title>
    <link href="/2022/03/30/demo1-demo2/"/>
    <url>/2022/03/30/demo1-demo2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>world</title>
    <link href="/2022/03/30/hello/world/"/>
    <url>/2022/03/30/hello/world/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>haha</title>
    <link href="/2022/03/30/hello/hhh/"/>
    <url>/2022/03/30/hello/hhh/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>first blog</title>
    <link href="/2022/03/30/first-blog/"/>
    <url>/2022/03/30/first-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/29/hello-world/"/>
    <url>/2022/03/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>123</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
